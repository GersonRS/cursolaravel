/**
 * angular-permission
 * Route permission and access control as simple as it can get
 * @version v2.3.8 - 2016-05-07
 * @link https://github.com/Narzerus/angular-permission
 * @author Rafael Vidaurre <narzerus@gmail.com> (http://www.rafaelvidaurre.com), Blazej Krysiak
 *   <blazej.krysiak@gmail.com>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */

!function () {
  "use strict";
  function a(a) {
    a.decorator("parent", function (a, b) {
      return a.self.$$state = function () {
        return a
      }, a.self.areSetStatePermissions = function () {
        return angular.isDefined(a.data) && angular.isDefined(a.data.permissions)
      }, b(a)
    })
  }

  function b(a, b, c, d, e, f) {
    a.$on("$stateChangeStart", function (a, g, h, i, j, k) {
      function l() {
        c.toState = g, c.toParams = h, c.fromState = i, c.fromParams = j, c.options = k
      }

      function m(a) {
        angular.extend(g, {$$isAuthorizationFinished: a})
      }

      function n() {
        return g.$$isAuthorizationFinished
      }

      function o() {
        d.broadcastStateChangePermissionAccepted();
        var a = angular.extend({}, c.options, {notify: !1, location: !0});
        b.go(c.toState.name, c.toParams, a).then(function () {
          d.broadcastStateChangeSuccess()
        })
      }

      function p(a, c) {
        d.broadcastStateChangePermissionDenied(), c.resolveRedirectState(a).then(function (a) {
          b.go(a.state, a.params, a.options)
        })
      }

      if (!n() && (a.preventDefault(), m(!0), l(), !d.areStateEventsDefaultPrevented())) {
        d.broadcastStateChangePermissionStart();
        var q = new f;
        e.authorize(q).then(function () {
          o()
        })["catch"](function (a) {
          p(a, q)
        })["finally"](function () {
          m(!1)
        })
      }
    })
  }

  a.$inject = ["$stateProvider"], b.$inject = ["$rootScope", "$state", "TransitionProperties", "TransitionEvents", "StateAuthorization", "StatePermissionMap"], angular.module("permission", ["ui.router"]).config(a).run(b)
}(), function () {
  "use strict";
  function a(a) {
    "ngInject";
    function b(b) {
      var c = a.defer(), d = 0, e = angular.isArray(b) ? [] : {};
      return angular.forEach(b, function (b, f) {
        d++, a.when(b).then(function (a) {
          c.resolve(a)
        })["catch"](function (a) {
          e[f] = a, --d || c.reject(a)
        })
      }), 0 === d && c.reject(e), c.promise
    }

    return a.any = b, a
  }

  a.$inject = ["$delegate"], angular.module("permission").decorator("$q", a)
}(), function () {
  "use strict";
  var a = {
    enableElement: function (a) {
      a.removeAttr("disabled")
    }, disableElement: function (a) {
      a.attr("disabled", "disabled")
    }, showElement: function (a) {
      a.removeClass("ng-hide")
    }, hideElement: function (a) {
      a.addClass("ng-hide")
    }
  };
  angular.module("permission").constant("PermissionStrategies", a)
}(), function () {
  "use strict";
  var a = {toState: void 0, toParams: void 0, fromState: void 0, fromParams: void 0, options: void 0};
  angular.module("permission").value("TransitionProperties", a)
}(), function () {
  "use strict";
  function a(a, b) {
    function c() {
      return i() || h()
    }

    function d() {
      a.$broadcast("$stateChangePermissionStart", b.toState, b.toParams, b.options)
    }

    function e() {
      a.$broadcast("$stateChangePermissionAccepted", b.toState, b.toParams, b.options)
    }

    function f() {
      a.$broadcast("$stateChangeSuccess", b.toState, b.toParams, b.fromState, b.fromParams)
    }

    function g() {
      a.$broadcast("$stateChangePermissionDenied", b.toState, b.toParams, b.options)
    }

    function h() {
      return a.$broadcast("$stateChangeStart", b.toState, b.toParams, b.fromState, b.fromParams, b.options).defaultPrevented
    }

    function i() {
      return a.$broadcast("$stateChangePermissionStart", b.toState, b.toParams, b.options).defaultPrevented
    }

    this.areStateEventsDefaultPrevented = c, this.broadcastStateChangePermissionStart = d, this.broadcastStateChangePermissionAccepted = e, this.broadcastStateChangePermissionDenied = g, this.broadcastStateChangeSuccess = f
  }

  a.$inject = ["$rootScope", "TransitionProperties"], angular.module("permission").service("TransitionEvents", a)
}(), function () {
  "use strict";
  function a(a, b, c, d) {
    function e(a) {
      a = a || {}, this.only = h(a.only), this.except = h(a.except), this.redirectTo = a.redirectTo
    }

    function f(b, c) {
      return a.when(b.call(null, c)).then(function (a) {
        if (angular.isString(a))return {state: a};
        if (angular.isObject(a))return a;
        throw new TypeError('When used "redirectTo" as function, returned value must be string or object')
      })
    }

    function g(b, c) {
      if (!angular.isDefined(b["default"]))throw new ReferenceError('When used "redirectTo" as object, property "default" must be defined');
      var d = b[c];
      return angular.isDefined(d) || (d = b["default"]), angular.isFunction(d) ? f(d, c) : angular.isObject(d) ? a.resolve(d) : angular.isString(d) ? a.resolve({state: d}) : void 0
    }

    function h(a) {
      return angular.isString(a) ? [a] : angular.isArray(a) ? a : angular.isFunction(a) ? a.call(null, b) : []
    }

    return e.prototype.resolveRedirectState = function (b) {
      return angular.isFunction(this.redirectTo) ? f(this.redirectTo, b) : angular.isObject(this.redirectTo) ? g(this.redirectTo, b) : angular.isString(this.redirectTo) ? a.resolve({state: this.redirectTo}) : a.reject(null)
    }, e.prototype.resolvePropertyValidity = function (b) {
      return b.map(function (b) {
        if (c.hasRoleDefinition(b)) {
          var e = c.getRoleDefinition(b);
          return e.validateRole()
        }
        if (d.hasPermissionDefinition(b)) {
          var f = d.getPermissionDefinition(b);
          return f.validatePermission()
        }
        return a.reject(b)
      })
    }, e
  }

  a.$inject = ["$q", "TransitionProperties", "RoleStore", "PermissionStore"], angular.module("permission").factory("PermissionMap", a)
}(), function () {
  "use strict";
  function a(a, b) {
    function c() {
      this.parent.constructor.call(this);
      var c = a.toState.$$state(), d = c.path.slice().reverse();
      angular.forEach(d, function (a) {
        if (a.areSetStatePermissions()) {
          var c = new b(a.data.permissions);
          this.extendPermissionMap(c)
        }
      }, this)
    }

    return c.prototype = new b, c.constructor = c, c.prototype.parent = b.prototype, c.prototype.extendPermissionMap = function (a) {
      a.only.length && (this.only = this.only.concat([a.only])), a.except.length && (this.except = this.except.concat([a.except])), this.redirectTo = a.redirectTo
    }, c
  }

  a.$inject = ["TransitionProperties", "PermissionMap"], angular.module("permission").factory("StatePermissionMap", a)
}(), function () {
  "use strict";
  function a(a, b) {
    function c(a, b) {
      e(a, b), this.permissionName = a, this.validationFunction = b
    }

    function d(b, c) {
      var d = a.defer();
      return b ? d.resolve(c) : d.reject(c), d.promise
    }

    function e(a, b) {
      if (!angular.isString(a))throw new TypeError('Parameter "permissionName" name must be String');
      if (!angular.isFunction(b))throw new TypeError('Parameter "validationFunction" must be Function')
    }

    return c.prototype.validatePermission = function () {
      var a = this.validationFunction.call(null, this.permissionName, b);
      return angular.isFunction(a.then) || (a = d(a, this.permissionName)), a
    }, c
  }

  a.$inject = ["$q", "TransitionProperties"], angular.module("permission").factory("Permission", a)
}(), function () {
  "use strict";
  function a(a, b, c) {
    function d(a, c, d) {
      f(a, c, d), this.roleName = a, this.permissionNames = c || [], this.validationFunction = d, d && b.defineManyPermissions(c, d)
    }

    function e(b, c) {
      var d = a.defer();
      return b ? d.resolve(c) : d.reject(c), d.promise
    }

    function f(a, b, c) {
      if (!angular.isString(a))throw new TypeError('Parameter "roleName" name must be String');
      if (!angular.isArray(b))throw new TypeError('Parameter "permissionNames" must be Array');
      if (!b.length && !angular.isFunction(c))throw new TypeError('Parameter "validationFunction" must be provided for empty "permissionNames" array')
    }

    return d.prototype.validateRole = function () {
      if (this.permissionNames.length) {
        var d = this.permissionNames.map(function (c) {
          if (b.hasPermissionDefinition(c)) {
            var d = b.getPermissionDefinition(c), f = d.validatePermission();
            return angular.isFunction(f.then) || (f = e(f)), f
          }
          return a.reject()
        });
        return a.all(d)
      }
      var f = this.validationFunction.call(null, this.roleName, c);
      return angular.isFunction(f.then) || (f = e(f, this.roleName)), a.resolve(f)
    }, d
  }

  a.$inject = ["$q", "PermissionStore", "TransitionProperties"], angular.module("permission").factory("Role", a)
}(), function () {
  "use strict";
  function a(a) {
    function b(b, c) {
      var d = new a(b, c);
      i[b] = d
    }

    function c(a, c) {
      if (!angular.isArray(a))throw new TypeError('Parameter "permissionNames" name must be Array');
      angular.forEach(a, function (a) {
        b(a, c)
      })
    }

    function d(a) {
      delete i[a]
    }

    function e(a) {
      return angular.isDefined(i[a])
    }

    function f(a) {
      return i[a]
    }

    function g() {
      return i
    }

    function h() {
      i = {}
    }

    var i = {};
    this.definePermission = b, this.defineManyPermissions = c, this.removePermissionDefinition = d, this.hasPermissionDefinition = e, this.getPermissionDefinition = f, this.getStore = g, this.clearStore = h
  }

  a.$inject = ["Permission"], angular.module("permission").service("PermissionStore", a)
}(), function () {
  "use strict";
  function a(a) {
    function b(b, c, d) {
      h[b] = new a(b, c, d)
    }

    function c(a) {
      delete h[a]
    }

    function d(a) {
      return angular.isDefined(h[a])
    }

    function e(a) {
      return h[a]
    }

    function f() {
      return h
    }

    function g() {
      h = {}
    }

    var h = {};
    this.defineRole = b, this.getRoleDefinition = e, this.hasRoleDefinition = d, this.removeRoleDefinition = c, this.getStore = f, this.clearStore = g
  }

  a.$inject = ["Role"], angular.module("permission").service("RoleStore", a)
}(), function () {
  "use strict";
  function a(a, b, c, d) {
    return {
      restrict: "A",
      bindToController: {
        only: "=?permissionOnly",
        except: "=?permissionExcept",
        onAuthorized: "&?permissionOnAuthorized",
        onUnauthorized: "&?permissionOnUnauthorized",
        deprecatedOnly: "=only",
        deprecatedExcept: "=except"
      },
      controllerAs: "permission",
      controller: ["$scope", "$element", function (e, f) {
        function g() {
          angular.isFunction(i.onAuthorized) ? i.onAuthorized()(f) : d.showElement(f)
        }

        function h() {
          angular.isFunction(i.onUnauthorized) ? i.onUnauthorized()(f) : d.hideElement(f)
        }

        var i = this;
        (angular.isDefined(i.deprecatedOnly) || angular.isDefined(i.deprecatedExcept)) && a.warn('Attributes "only" and "except" are deprecated since 2.2.0+ and their support will be removed from 2.4.0. Use scoped "permission-only" and "permission-except" instead.'), e.$watchGroup(["permission.only", "permission.except", "permission.deprecatedOnly", "permission.deprecatedExcept"], function () {
          try {
            var d = new c({only: i.only || i.deprecatedOnly, except: i.except || i.deprecatedExcept});
            b.authorize(d).then(function () {
              g()
            })["catch"](function () {
              h()
            })
          } catch (e) {
            h(), a.error(e.message)
          }
        })
      }]
    }
  }

  a.$inject = ["$log", "Authorization", "PermissionMap", "PermissionStrategies"], angular.module("permission").directive("permission", a)
}(), function () {
  "use strict";
  function a(a) {
    function b(a) {
      return c(a)
    }

    function c(b) {
      var c = a.defer();
      return d(c, b), c.promise
    }

    function d(b, c) {
      var d = c.resolvePropertyValidity(c.except);
      a.any(d).then(function (a) {
        b.reject(a)
      })["catch"](function () {
        e(b, c)
      })
    }

    function e(b, c) {
      if (!c.only.length)return void b.resolve();
      var d = c.resolvePropertyValidity(c.only);
      a.any(d).then(function (a) {
        b.resolve(a)
      })["catch"](function (a) {
        b.reject(a)
      })
    }

    this.authorize = b
  }

  a.$inject = ["$q"], angular.module("permission").service("Authorization", a)
}(), function () {
  "use strict";
  function a(a) {
    function b(a) {
      return c(a)
    }

    function c(b) {
      var c = a.defer();
      return d(c, b), c.promise
    }

    function d(b, c) {
      var d = f(c.except, c);
      a.all(d).then(function (a) {
        b.reject(a)
      })["catch"](function () {
        e(b, c)
      })
    }

    function e(b, c) {
      if (!c.only.length)return void b.resolve();
      var d = f(c.only, c);
      a.all(d).then(function (a) {
        b.resolve(a)
      })["catch"](function (a) {
        b.reject(a)
      })
    }

    function f(b, c) {
      return b.length ? b.map(function (b) {
        var d = c.resolvePropertyValidity(b);
        return a.any(d)
      }) : [a.reject()]
    }

    this.authorize = b
  }

  a.$inject = ["$q"], angular.module("permission").service("StateAuthorization", a)
}();
//# sourceMappingURL=angular-permission.min.js.map